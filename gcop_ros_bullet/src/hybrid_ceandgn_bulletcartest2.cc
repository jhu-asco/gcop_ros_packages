/** This example computes optimal trajectories for a rccar using Cross Entropy based sampling method. 
 * Gcop library is used for creating rccar system and algorithm etc.
 * Rviz is used for display
 */
//System stuff
#include <iostream>

//Gcop Stuff
#include <gcop/systemce.h>
#include <gcop/gndocp.h>
#include <gcop/rnlqcost.h>
#include <gcop/bulletrccar.h>
#include <gcop/bulletworld.h>
#include <gcop/tparam.h>
//#include "utils.h"
//#include "controltparam.h"

// Ros stuff
#include <ros/ros.h>
#include <dynamic_reconfigure/server.h>
#include <gcop_ros_bullet/CEInterfaceConfig.h>
#include <visualization_msgs/Marker.h>
#include <sensor_msgs/JointState.h>
#include <XmlRpcValue.h>
#include <tf/transform_broadcaster.h>
#include <std_msgs/Float64MultiArray.h>
#include "gcop_comm/CtrlTraj.h"//msg for publishing ctrl trajectory
#include <std_msgs/Float64.h>

#define USE_SPLINEPARAM

#ifdef USE_SPLINEPARAM
#include <gcop/uniformsplinetparam.h>
#else
#include <gcop/controltparam.h>
#endif


using namespace std;
using namespace Eigen;
using namespace gcop;

typedef SystemCe<Vector4d, 4, 2, Dynamic> RccarCe;
typedef GnDocp<Vector4d, 4, 2, Dynamic, 6> RccarGn;
typedef Matrix<double, 6, 1> Vector6d;//#DEBUG

//Global variable:
boost::shared_ptr<RccarCe> ce;///<Cross entropy based solver
boost::shared_ptr<RccarGn> gn;///<Cross entropy based solver
boost::shared_ptr<Bulletrccar> sys;///Bullet rccar system
vector<Vector4d> xs;///< State trajectory of the system
vector<Vector2d> us;///< Controls for the trajectory of the system
vector<double> ts;///< Times for trajectory
vector<double> zs;///< Height of the car along the trajectory (same as xs) only used for visualization
int Nreq;///< Number of segments requested for gcop trajectory
Vector4d xf(0,0,0,0);///< final state
Vector4d x0bar(1,1,0,0);///< perturbed initial state
double marker_height;///< Height of the final arrow
double tf_gn = 2.0;///< Time horizon for gauss newton shooting

vector<Vector4d> xs_gn;///< State trajectory of the system (For feedback)
vector<Vector2d> us_gn;///< Controls for the trajectory of the system
vector<double> ts_gn;///< Times for trajectory
Vector4d xf_gn(0,0,0,0);///< final state

//ros publisher and subscribers:
ros::Publisher joint_pub;///<Rccar model joint publisher for animation
ros::Publisher traj_pub;///<Rviz best trajectory publisher
ros::Publisher sampletraj_pub;///<Rviz sample trajectories publisher
ros::Publisher gcoptraj_pub;///<Publisher for gcop trajectory (States, times, Controls)
ros::Publisher costlog_pub;///<Publish the cost after every iteration for logging

//Messages:
visualization_msgs::Marker line_strip;///<Best trajectory message
visualization_msgs::Marker gnline_strip;///<Best gn trajectory message
visualization_msgs::Marker sampleline_strip;///<Sample trajectory message
visualization_msgs::Marker goal_arrow;///<Best trajectory message
sensor_msgs::JointState joint_state;///< Joint states for wheels in animation
gcop_comm::CtrlTraj trajectory;

//tf
tf::TransformBroadcaster *broadcaster;

/** Helper function for converting ros vector list into eigen vector
 * @param vec  output from my_list
 * @param my_list input ros list obtained from nh.getParam
 *
 *  The list should be an array and each value should be a doule
 */
void xml2vec(VectorXd &vec, XmlRpc::XmlRpcValue &my_list)
{
	ROS_ASSERT(my_list.getType() == XmlRpc::XmlRpcValue::TypeArray);
	ROS_ASSERT(my_list.size() > 0);
	vec.resize(my_list.size());
	//cout<<my_list.size()<<endl;
	//ROS_ASSERT(vec.size() <= my_list.size()); //Desired size

	for (int32_t i = 0; i < my_list.size(); i++) 
	{
				ROS_ASSERT(my_list[i].getType() == XmlRpc::XmlRpcValue::TypeDouble);
				cout<<"my_list["<<i<<"]\t"<<my_list[i]<<endl;
			  vec[i] =  (double)(my_list[i]);
	}
}

/**
 * External render function for displaying sample trajectories from CE method
 */
 void render_trajectory(int id, vector<Vector4d> &xss)
 {
   sampleline_strip.id = id;
   //Can use pragma here OpenMP
   for(int count1 = 0;count1 < xs.size(); count1++)
   {
     sampleline_strip.points[count1].x = xss[count1][0];
     sampleline_strip.points[count1].y = xss[count1][1];
     sampleline_strip.points[count1].z = zs[count1];
     //cout<<"count,x,y,z: "<<count1<<"\t"<<xss[count1][0]<<"\t"<<xss[count1][1]<<"\t"<<zs[count1]<<endl;
   }
   sampletraj_pub.publish(sampleline_strip);
   //getchar();//#DEBUG
 }

/**  Interface for configuring /iterating through the solver
 * @param config Configuration class autogenerated from dynamic reconfiguration
 * @param level  Each change in reconfiguration is added to level through a bitwise and operation
 */
void ParamreqCallback(gcop_ros_bullet::CEInterfaceConfig &config, uint32_t level) 
{
  if(config.iterate)
  {
    ros::Time currtime;

    //Set rviz goal model also
    goal_arrow.pose.position.x = xf(0);
    goal_arrow.pose.position.y = xf(1);
    goal_arrow.pose.position.z = marker_height;
    tf::quaternionTFToMsg(tf::createQuaternionFromYaw(xf(2)+M_PI/2), goal_arrow.pose.orientation);
    traj_pub.publish(goal_arrow);

    //Publishing initial trajectory:
    line_strip.header.stamp  = ros::Time::now();
    for(int i =0;i<xs.size(); i++)
    {
      //geometry_msgs::Point p;
      line_strip.points[i].x = xs[i][0];
      line_strip.points[i].y = xs[i][1];
      line_strip.points[i].z = zs[i];//Need to add  this to state or somehow get it #TODO
    }
    traj_pub.publish(line_strip);

    //Publish initial trajectory cost:
    //Publish the cost of the initial trajectory:
    {
      double cost1 = 0;
      int N = us.size();
      int count_cost = 0;
      for(count_cost = 0;count_cost < N;count_cost++)
      {
        double h = (ts[count_cost+1] - ts[count_cost]);
        cost1 += (ce->cost).L(ts[count_cost], xs[count_cost], us[count_cost], h, 0);
      }
      cost1 += (ce->cost).L(ts[count_cost], xs[count_cost], us[count_cost-1], 0, 0);
      cout<<"Initial cost: "<<cost1<<endl;

      std_msgs::Float64 costmsg;///<Message with the current cost after every iteration
      costmsg.data = cost1;
      costlog_pub.publish(costmsg);
    }

    cout<<"Iterating: "<<endl;
    for (int i = 0; i < config.Nit; ++i) {
      currtime = ros::Time::now();
      ce->Iterate();
      cout << "Iteration #" << i << " took: " << (ros::Time::now() - currtime).toSec()*1e3 << " ms." << endl;
      cout << "Cost=" << ce->J << endl;

      std_msgs::Float64 costmsg;///<Message with the current cost after every iteration
      costmsg.data = ce->J;
      costlog_pub.publish(costmsg);
      costmsg.data = ce->nofevaluations;
      costlog_pub.publish(costmsg);
      //Publish rviz Trajectory for visualization:
      line_strip.header.stamp  = ros::Time::now();

      for(int i =0;i<xs.size(); i++)
      {
        //geometry_msgs::Point p;
        line_strip.points[i].x = xs[i][0];
        line_strip.points[i].y = xs[i][1];
        line_strip.points[i].z = zs[i];//Need to add  this to state or somehow get it #TODO
      }
      traj_pub.publish(line_strip);


    }
    
    for(int i =0;i < us.size();i++)
    {
      cout<<"us["<<i<<"]: "<<us[i].transpose()<<endl;
      cout<<"xs["<<i+1<<"]: "<<xs[i+1].transpose()<<endl;
    }//#DEBUG
    //Publish control trajectory when parameter is set:
    for (int count = 0;count<Nreq;count++)
    {
	    for(int count1 = 0;count1 < 2;count1++)
	    {
		    trajectory.ctrl[count].ctrlvec[count1] = us[count](count1);
	    }
    }
 
    config.iterate = false;
  }
  if(config.send_traj)
  {
    ROS_INFO("Publishing Trajectory");
    gcoptraj_pub.publish(trajectory);
    config.send_traj = false;
  }
  if(config.animate)
  {
    //Run the system:
    sys->reset(x0bar, ts[0]);
    
    int count_gn = 0;
    double h = (ce->cost.tf)/us.size();//h for the original problem
    int N_gn = round(tf_gn/h);
    cout<<"ce->cost.tf: "<<(ce->cost.tf)<<endl;
    cout<<"N_gn: "<<(N_gn)<<endl;

    //while(count_gn*tf_gn < (ce->cost.tf))
    while(count_gn*N_gn < us.size())
    {
      //set x0 for gn based on current car state
      sys->setinitialstate(xs_gn[0]);//For Feedback this is not needed. It is used here to find the current car state
      //verify new setinitialstate:
      //modify initialstate:
      btVector3 &carorigin = (sys->initialstate)->cartransform.getOrigin();
      carorigin[2] += 0.3;//set the car 0.3 m high and check where it settles down:
      /*if(count_gn%2 == 0)
      {
        carorigin[0] += 0.1;//noise in feedback
        carorigin[1] += 0.1;//noise in feedback
      }
      else
      {
        carorigin[0] -= 0.1;
        carorigin[1] -= 0.1;
      }
      */
      sys->setinitialstate(*(sys->initialstate), xs_gn[0]);//This should be called by Feedback loop to set the current car state. Carstate: cartransform, carvel, carangularvel
      //getchar();
      //set the gn controls from ce trajectory:
      //us_gn from us
      //  int index_start = round((count_gn*tf_gn)/h);
      // int index_end = round((count_gn+1)*tf_gn/h);
      //index_end  = index_end < us.size()?index_end:(us.size()-1);//Bind the final index 
      int us_index = 0;
      for(int count_us = 0; count_us < N_gn; count_us++)
      {
        us_index = (count_gn*N_gn + count_us);
        if(us_index < us.size())
          us_gn[count_us] = us[us_index];
        else
          us_gn[count_us] = Vector2d::Zero();
        cout<<"us_gn["<<count_us<<"]: "<<us_gn[count_us].transpose()<<endl;
      }
      gn->tparam.To(gn->s, ts_gn, xs_gn, us_gn, 0);//Convert the controls into a single vector for gn
      /*
      if(gn->lm)
      {
        int info = (gn->lm)->minimizeInit(gn->s);//Reinitialize the gn everytime
        cout<<"info: "<<info<<endl;
      }
      */
      if(gn->lm)
      {
        delete (gn->lm);
        gn->lm = 0;
      }
      //getchar();

      //set the xf_gn from ce trajectory
      int xf_index = (count_gn+1)*N_gn;
      if(xf_index < xs.size()-1)
        xf_gn = xs[xf_index];
      else
      {
        cout<<"Final Segment!"<<endl;//#DEBUG
        xf_gn = xf;//For last time use the actual final goal instead of the trajectory
      }
      //#DEBUG:
      cout<<"xf_gn: "<<xf_gn.transpose()<<endl;
      //getchar();


      //verify update xs_gn and corresponding xs in CE
      gn->Update(false);//Update xs_gn from us_gn

      //#DEBUG:
      for(int count_xs = 0;count_xs <= N_gn; count_xs++)
      {
        int xs_index = (count_gn*N_gn + count_xs);
        cout<<"xs_gn["<<count_xs<<"]: "<<xs_gn[count_xs].transpose()<<endl;
        if(xs_index < xs.size())
        {
          cout<<"xsdiff["<<xs_index<<"]: "<<(xs[xs_index].transpose() - xs_gn[count_xs].transpose())<<endl;
        }
      }
      //getchar();
      //Print initial cost:
      //Publish the cost of the initial trajectory:
      {
        double cost1 = 0;
        int count_cost = 0;
        for(count_cost = 0;count_cost < N_gn;count_cost++)
        {
          double h = (ts_gn[count_cost+1] - ts_gn[count_cost]);
          cost1 += (gn->cost).L(ts_gn[count_cost], xs_gn[count_cost], us_gn[count_cost], h, 0);
        }
        cost1 += (gn->cost).L(ts_gn[count_cost], xs_gn[count_cost], us_gn[count_cost-1], 0, 0);
        cout<<"Initial cost: "<<cost1<<endl;
      }
      //getchar();
      //iterate gn and check gn cost. 
      for(int count = 0;count < 5;count++)
      {
        gn->Iterate();
        cout<<"Optimal Cost: "<<(gn->J)<<endl;
      }
      for(int count =0;count < us_gn.size();count++)
      {
        cout<<"us_gn["<<count<<"]: "<<us_gn[count].transpose()<<endl;
        cout<<"xs_gn["<<count+1<<"]: "<<xs_gn[count+1].transpose()<<endl;
      }//#DEBUG

      //getchar();

      //reset car state and update the trajectory with new controls.
      sys->reset(xs_gn[0],ts_gn[0]);
      for(int count1 = 0;count1 < N_gn;count1++)
      {
        sys->Step2(us_gn[count1], ts_gn[count1+1]-ts_gn[count1]);
        //Set the car joint stuff:
        joint_state.header.stamp = ros::Time::now();
        //Back wheel
        joint_state.position[2] = 0;
        //steering angle
        joint_state.position[0] = sys->gVehicleSteering;
        joint_state.position[1] = sys->gVehicleSteering;
        //send joint state
        joint_pub.publish(joint_state);
        //Set the pose for the car:
        btTransform chassistransform = (sys->m_carChassis)->getWorldTransform();
        btQuaternion chassisquat = chassistransform.getRotation();
        btVector3 chassisorig = chassistransform.getOrigin();
        tf::Transform tf_chassistransform;
        tf_chassistransform.setRotation(tf::Quaternion(chassisquat.x(), chassisquat.y(), chassisquat.z(), chassisquat.w()));
        tf_chassistransform.setOrigin(tf::Vector3(chassisorig.x(), chassisorig.y(), chassisorig.z()));
        broadcaster->sendTransform(tf::StampedTransform(tf_chassistransform, ros::Time::now(), "world", "base_link"));
        cout<<"xsdiff["<<count1+1<<"]: "<<((sys->x)-xs_gn[count1+1]).transpose()<<endl;
        cout<<"us_opt["<<count1<<"]: "<<us_gn[count1].transpose()<<endl;
        cout<<"xs_gn["<<count1+1<<"]: "<<xs_gn[count1+1].transpose()<<endl;
        usleep((ts[count1+1] - ts[count1])*1e6);//microseconds
      }
      //set x0 for gn based on current car state
      //sys->setinitialstate(xs_gn[0]);
      //publish the small trajectory #TODO
      //Publish rviz Trajectory for visualization:
      gnline_strip.header.stamp  = ros::Time::now();
      gnline_strip.id = 10+count_gn;//Same namespace everything just a separate id

      for(int i =0;i<xs_gn.size(); i++)
      {
        //geometry_msgs::Point p;
        gnline_strip.points[i].x = xs_gn[i][0];
        gnline_strip.points[i].y = xs_gn[i][1];
        gnline_strip.points[i].z = zs[i];//Need to add  this to state or somehow get it #TODO
      }
      traj_pub.publish(gnline_strip);


      //getchar();

      count_gn++;
    }
    sys->initialstate = 0;
    config.animate = false;
  }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, "cecartest");

  ros::NodeHandle nh("~");

  //setup tf
	broadcaster = new tf::TransformBroadcaster();

  //Setup publishers and subscribers:
	traj_pub = nh.advertise<visualization_msgs::Marker>("best_traj", 1);
	sampletraj_pub = nh.advertise<visualization_msgs::Marker>("sample_traj", 100);
	joint_pub = nh.advertise<sensor_msgs::JointState>("/joint_states", 1);
  gcoptraj_pub = nh.advertise<gcop_comm::CtrlTraj>("ctrltraj",1);
  costlog_pub = nh.advertise<std_msgs::Float64>("cost",10);

  /* Parametersf for solver */
  int N = 32;        // number of segments
  double tf = 5;    // time horizon

  nh.getParam("N",N);
  ROS_ASSERT(2*int(N/2) == N);
  nh.getParam("tf",tf);
  nh.getParam("tf_gn",tf_gn);

  if(!nh.getParam("marker_height",marker_height))
    marker_height = 1.0;

  cout<<"N: "<<N<<endl;
  cout<<"tf: "<<tf<<endl;
  cout<<"marker_height: "<<marker_height<<endl;

  double h = tf/N;   // time step

  //Create Bullet world and rccar system:
  BulletWorld world(true);//Set the up axis as z for this world

  zs.resize(N+1);//<Resize the height vector and pass it to the rccar system
  sys.reset(new Bulletrccar(world, &zs));
  sys->initialz = 0.12;
  sys->gain_cmdvelocity = 1;
  sys->kp_steer = 0.2;
  sys->kp_torque = 100;
  sys->gain_cmdvelocity = 1.04;
  //sys->kp_torque = 25;
  sys->steeringClamp = 15.0*(M_PI/180.0);
  sys->U.lb[0] = -(sys->steeringClamp);
  sys->U.ub[1] = (sys->steeringClamp);
  sys->U.bnd = true;

  nh.getParam("initialz", (sys->initialz));

  sys->offsettrans.setIdentity();
  sys->offsettransinv.setIdentity();

  //Load Ground
  {
    std::string filename;
    nh.getParam("mesh",filename);
    cout<<"Filename: "<<filename<<endl;
    btCollisionShape *groundShape;
    if(filename.compare("plane") == 0)
      groundShape = world.CreateGroundPlane(20,20);
    else
      groundShape= world.CreateMeshFromSTL(filename.c_str());//20 by 20 long plane

    btTransform tr;
    tr.setOrigin(btVector3(0, 0, 0));
    tr.setRotation(btQuaternion(0,0,0));
    world.LocalCreateRigidBody(0,tr, groundShape);
  }

  // initial state
  Vector4d x0(1,1,0,0);


  // cost
  RnLqCost<4, 2, Dynamic, 6> cost(*sys, tf, xf);

  //Gn cost:
  int N_gn = round(tf_gn/h);
  for(int count = 0; count <= N_gn; count++)
    ts_gn.push_back(count*h);
  ts_gn[N_gn] = tf_gn;//Set the last time to tf_gn 
  us_gn.resize(N_gn);
  xs_gn.resize(N_gn+1);
  RnLqCost<4, 2, Dynamic, 6> cost_gn(*sys, tf_gn, xf_gn);

  {
    VectorXd temp;
    XmlRpc::XmlRpcValue list;

    //Initial state
    if(nh.getParam("x0", list))
      xml2vec(temp,list);
    ROS_ASSERT(temp.size() == 4);

    x0 = temp;

    if(nh.getParam("x0bar", list))
    {
      xml2vec(temp,list);
      ROS_ASSERT(temp.size() == 4);
      x0bar = temp;
    }
    else
    {
      x0bar = x0;
    }

    if(nh.getParam("xf", list))
      xml2vec(temp,list);
    ROS_ASSERT(temp.size() == 4);

    xf = temp;


    if(nh.getParam("Q", list))
      xml2vec(temp,list);
    ROS_ASSERT(temp.size() == 4);

    cost.Q = temp.asDiagonal();

    if(nh.getParam("Qf", list))
      xml2vec(temp,list);
    ROS_ASSERT(temp.size() == 4);

    cost.Qf = temp.asDiagonal();

    if(nh.getParam("R", list))
      xml2vec(temp,list);
    ROS_ASSERT(temp.size() == 2);

    cost.R = temp.asDiagonal();

    cost.UpdateGains();//#TODO Make this somehow implicit in the cost function otherwise becomes a coder's burden !

    cout<<"x0: "<<x0.transpose()<<endl;
    cout<<"xf: "<<xf.transpose()<<endl;
    cout<<"Q: "<<endl<<cost.Q<<endl;
    cout<<"Qf: "<<endl<<cost.Qf<<endl;
    cout<<"R: "<<endl<<cost.R<<endl;

    cost_gn.Qf = cost.Qf;
    cost_gn.Q.setZero();
    cost_gn.R = cost.R;
    cost_gn.UpdateGains();//#TODO Make this somehow implicit in the cost function otherwise becomes a coder's burden !
  }

  // times
  ts.resize(N+1);
  for (int k = 0; k <=N; ++k)
    ts[k] = k*h;

  // states
  xs.resize(N+1);
  // initial state

  // initial controls [ If more complicated control is needed hardcode them here]
  us.resize(N);

  for (int i = 0; i < N/2; ++i) {
    us[i] = Vector2d(0.5, 0);
    us[N/2+i] = Vector2d(0.5, 0);    
    //us[i] = Vector2d(1, -.1);
    //us[N/2+i] = Vector2d(1, -.1);    
  }
  //Set initial state:
  xs[0] = x0;
  /*Initialize xs to x0
  for(int i = 0; i <= N; ++)
  {
    xs[i] = x0;
  }
  */

  Vector2d du(.2, .1);///<Hardcoded if needed change the du and de here

  Vector2d e(.001, .001);

  vector<Vector2d> dus(N, du);
  vector<Vector2d> es(N, e);

  //Create Parametrization:
  int Nk = 10;
  nh.getParam("Nk", Nk);

#ifdef USE_SPLINEPARAM
  VectorXd tks(Nk+1);
#else
  vector<double> tks(Nk+1);
#endif
  for (int k = 0; k <=Nk; ++k)
  {
    tks[k] = k*(tf/Nk);
  }

#ifdef USE_SPLINEPARAM
  UniformSplineTparam<Vector4d, 4, 2> ctp(*sys, tks);
#else
  ControlTparam<Vector4d, 4, 2> ctp(*sys, tks);
#endif


  Tparam<Vector4d, 4, 2> tp_gn(*sys, N_gn*2);// default/no parametrization for GN Can add parametrization if we convert back and forth

  gn.reset(new RccarGn(*sys, cost_gn, tp_gn, ts_gn, xs_gn, us_gn));  
  gn->debug = true;

  ce.reset(new RccarCe(*sys, cost, ctp, ts, xs, us, 0, dus, es));//Can pass custom parameters here too
  ce->ce.mras = false;///<#TODO Find out what these are (This is a different type of CE sampling method which uses all the samples instead of only the elite samples)
  ce->ce.inc = false;///<#TODO Find out what these are
  ce->external_render = &render_trajectory;

  nh.getParam("Ns", ce->Ns);


  ce->debug = true; 

  //Set up dynamic reconfigure:
	dynamic_reconfigure::Server<gcop_ros_bullet::CEInterfaceConfig> server;
	dynamic_reconfigure::Server<gcop_ros_bullet::CEInterfaceConfig>::CallbackType f = boost::bind(&ParamreqCallback, _1, _2);
	server.setCallback(f);

  //Print the current trajectory :
  cout<<"us_size"<<us.size()<<endl;
  for(int i =0;i < us.size();i++)
  {
    cout<<"us["<<i<<"]: "<<us[i].transpose()<<endl;
    cout<<"xs["<<i+1<<"]: "<<xs[i+1].transpose()<<endl;
  }

  //Setup Trajectory variable for visualization:
  line_strip.header.frame_id = "/world";
	line_strip.ns = "traj";
	line_strip.action = visualization_msgs::Marker::ADD;
	line_strip.pose.orientation.w = 1.0;
	line_strip.id = 1;
	line_strip.type = visualization_msgs::Marker::LINE_STRIP;
	line_strip.scale.x = 0.1;
	line_strip.color.r = 1.0;
	line_strip.color.a = 1.0;
  line_strip.points.resize(xs.size());
  // gn line setup:
  gnline_strip = line_strip;//copy from above
  gnline_strip.id = 10;//Same namespace everything just a separate id
  gnline_strip.color.g = 1.0;
  gnline_strip.color.r = 0.0;
  gnline_strip.points.resize(xs_gn.size());
  //Setup sample trajectory
  sampleline_strip.header.frame_id = "/world";
	sampleline_strip.ns = "sampletraj";
	sampleline_strip.action = visualization_msgs::Marker::ADD;
	sampleline_strip.pose.orientation.w = 1.0;
	sampleline_strip.id = 1;
	sampleline_strip.type = visualization_msgs::Marker::LINE_STRIP;
	sampleline_strip.scale.x = 0.01;
	sampleline_strip.color.b = 1.0;
	sampleline_strip.color.a = 1.0;
  sampleline_strip.points.resize(xs.size());

  //Create a cylinder marker:
  goal_arrow.header.frame_id="/world";
  goal_arrow.ns = "goalmarker";
  goal_arrow.action = visualization_msgs::Marker::ADD;
  goal_arrow.id = 1000;//Some big number which should not match wit others
  goal_arrow.type = visualization_msgs::Marker::ARROW;
  goal_arrow.pose.orientation.w = 1.0;
  goal_arrow.scale.x = 1.5;
  goal_arrow.scale.y = 0.1;
  goal_arrow.scale.z = 0.1;
  goal_arrow.color.r = 1.0;
  goal_arrow.color.a = 1.0;

  //initializing joint msg for animation
	joint_state.name.resize(3);
	//joint_state.header.frame_id = "movingcar";//no namespace for now since only one car present
	joint_state.position.resize(3);
	joint_state.name[0] = "base_to_frontwheel1";
	joint_state.name[1] = "base_to_frontwheel2";
	joint_state.name[2] = "base_to_backwheel1";
  // Initialize control trajectory for publishing:

  cout<<"Send Trajectory SET "<<endl;
  Nreq = N;
  nh.getParam("Nreq",Nreq);
  assert((Nreq <= N) && (Nreq >0));
  trajectory.N = Nreq;
  trajectory.ctrl.resize(Nreq);
  trajectory.time.assign(ts.begin(), ts.begin()+Nreq+1);
  for(int count1 = 0;count1 < Nreq; count1++)
  {
	  trajectory.ctrl[count1].ctrlvec.resize(2);//2 controls
  }

  while(ros::ok())
  {
    ros::spinOnce();
    usleep(10000);//100 Hz roughly spinning
  }
  //ce.reset();//Clear ce
  
  return 0;
}
